import { pool } from '../config/database';
import type { Item, CreateItemRequest, MoveItemRequest } from '../types';

export class ItemModel {
  static async findByColumnId(columnId: number): Promise<Item[]> {
    const result = await pool.query(`
      SELECT
        i.id, i.column_id, i.title, i.description, i.position, i.start_date, i.end_date, i.effort, i.label, i.priority, i.archived, i.created_at, i.updated_at,
        COALESCE((
          SELECT json_agg(
            json_build_object(
              'id', t.id,
              'name', t.name,
              'color', t.color,
              'created_at', t.created_at,
              'updated_at', t.updated_at
            )
          )
          FROM item_tags it
          LEFT JOIN tags t ON it.tag_id = t.id
          WHERE it.item_id = i.id
        ), '[]'::json) as tags,
        COALESCE((
          SELECT json_agg(
            json_build_object(
              'id', u.id,
              'email', u.email,
              'name', u.name
            )
          )
          FROM item_users iu
          LEFT JOIN users u ON iu.user_id = u.id
          WHERE iu.item_id = i.id
        ), '[]'::json) as assigned_users
      FROM items i
      WHERE i.column_id = $1 AND i.archived = FALSE
      ORDER BY i.position
    `, [columnId]);
    return result.rows;
  }

  static async findById(id: number): Promise<Item | null> {
    const result = await pool.query(`
      SELECT
        i.id, i.column_id, i.title, i.description, i.position, i.start_date, i.end_date, i.effort, i.label, i.priority, i.archived, i.created_at, i.updated_at,
        COALESCE((
          SELECT json_agg(
            json_build_object(
              'id', t.id,
              'name', t.name,
              'color', t.color,
              'created_at', t.created_at,
              'updated_at', t.updated_at
            )
          )
          FROM item_tags it
          LEFT JOIN tags t ON it.tag_id = t.id
          WHERE it.item_id = i.id
        ), '[]'::json) as tags,
        COALESCE((
          SELECT json_agg(
            json_build_object(
              'id', u.id,
              'email', u.email,
              'name', u.name
            )
          )
          FROM item_users iu
          LEFT JOIN users u ON iu.user_id = u.id
          WHERE iu.item_id = i.id
        ), '[]'::json) as assigned_users
      FROM items i
      WHERE i.id = $1
    `, [id]);
    return result.rows[0] || null;
  }

  static async create(columnId: number, itemData: CreateItemRequest): Promise<Item> {
    const client = await pool.connect();

    try {
      await client.query('BEGIN');

      // Get the highest position for this column
      const positionResult = await client.query(`
        SELECT COALESCE(MAX(position), -1) + 1 as next_position
        FROM items
        WHERE column_id = $1
      `, [columnId]);

      const position = itemData.position ?? positionResult.rows[0].next_position;

      const result = await client.query(`
        INSERT INTO items (column_id, title, description, position, start_date, end_date, effort, label, priority, archived, created_at, updated_at)
        VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, FALSE, NOW(), NOW())
        RETURNING id, column_id, title, description, position, start_date, end_date, effort, label, priority, archived, created_at, updated_at
      `, [columnId, itemData.title, itemData.description || null, position, itemData.start_date || null, itemData.end_date || null, itemData.effort || null, itemData.label || null, itemData.priority || null]);

      const item = result.rows[0];

       // Handle tags if provided
       if (itemData.tag_ids && itemData.tag_ids.length > 0) {
         const tagValues = itemData.tag_ids.map((tagId, index) => `($1, $${index + 2})`).join(', ');
         const tagParams = [item.id, ...itemData.tag_ids];
         await client.query(`
           INSERT INTO item_tags (item_id, tag_id)
           VALUES ${tagValues}
         `, tagParams);
       }

       // Handle users if provided
       if (itemData.user_ids && itemData.user_ids.length > 0) {
         const userValues = itemData.user_ids.map((userId, index) => `($1, $${index + 2})`).join(', ');
         const userParams = [item.id, ...itemData.user_ids];
         await client.query(`
           INSERT INTO item_users (item_id, user_id)
           VALUES ${userValues}
         `, userParams);
       }

      await client.query('COMMIT');

      // Fetch the complete item with tags
      return await this.findById(item.id) as Item;
    } catch (error) {
      await client.query('ROLLBACK');
      throw error;
    } finally {
      client.release();
    }
  }

  static async update(id: number, itemData: Partial<CreateItemRequest>): Promise<Item | null> {
    const client = await pool.connect();

    try {
      await client.query('BEGIN');

      // Check if item exists and lock it for update
      const existingItem = await client.query('SELECT id FROM items WHERE id = $1 FOR UPDATE', [id]);
      if (existingItem.rows.length === 0) {
        await client.query('ROLLBACK');
        return null;
      }

      const fields = [];
      const values = [];
      let paramCount = 1;

      if (itemData.title !== undefined) {
        fields.push(`title = $${paramCount}`);
        values.push(itemData.title);
        paramCount++;
      }

      if (itemData.description !== undefined) {
        fields.push(`description = $${paramCount}`);
        values.push(itemData.description);
        paramCount++;
      }

      if (itemData.position !== undefined) {
        fields.push(`position = $${paramCount}`);
        values.push(itemData.position);
        paramCount++;
      }

      if (itemData.start_date !== undefined) {
        fields.push(`start_date = $${paramCount}`);
        values.push(itemData.start_date);
        paramCount++;
      }

      if (itemData.end_date !== undefined) {
        fields.push(`end_date = $${paramCount}`);
        values.push(itemData.end_date);
        paramCount++;
      }

      if (itemData.effort !== undefined) {
        fields.push(`effort = $${paramCount}`);
        values.push(itemData.effort);
        paramCount++;
      }

      if ('label' in itemData) {
        fields.push(`label = $${paramCount}`);
        values.push(itemData.label || null);
        paramCount++;
      }

      if ('priority' in itemData) {
        fields.push(`priority = $${paramCount}`);
        values.push(itemData.priority || null);
        paramCount++;
      }

      if (fields.length > 0) {
        fields.push(`updated_at = NOW()`);
        values.push(id);

        const result = await client.query(`
          UPDATE items
          SET ${fields.join(', ')}
          WHERE id = $${paramCount}
          RETURNING id
        `, values);
      }

       // Handle tags if provided
       if (itemData.tag_ids !== undefined) {
         // Remove all existing tags for this item
         await client.query('DELETE FROM item_tags WHERE item_id = $1', [id]);

         // Add new tags if any
         if (itemData.tag_ids.length > 0) {
           const tagValues = itemData.tag_ids.map((tagId, index) => `($1, $${index + 2})`).join(', ');
           const tagParams = [id, ...itemData.tag_ids];
           await client.query(`
             INSERT INTO item_tags (item_id, tag_id)
             VALUES ${tagValues}
           `, tagParams);
         }
       }

       // Handle users if provided
       if (itemData.user_ids !== undefined) {
         // Remove all existing users for this item
         await client.query('DELETE FROM item_users WHERE item_id = $1', [id]);

         // Add new users if any
         if (itemData.user_ids.length > 0) {
           const userValues = itemData.user_ids.map((userId, index) => `($1, $${index + 2})`).join(', ');
           const userParams = [id, ...itemData.user_ids];
           await client.query(`
             INSERT INTO item_users (item_id, user_id)
             VALUES ${userValues}
           `, userParams);
         }
       }

      await client.query('COMMIT');

      // Fetch the complete item with tags
      return await this.findById(id);
    } catch (error) {
      await client.query('ROLLBACK');
      throw error;
    } finally {
      client.release();
    }
  }

  static async delete(id: number): Promise<boolean> {
    const result = await pool.query('DELETE FROM items WHERE id = $1', [id]);
    return (result.rowCount ?? 0) > 0;
  }

  static async archive(id: number, archived: boolean = true): Promise<Item | null> {
    const result = await pool.query(`
      UPDATE items
      SET archived = $1, updated_at = NOW()
      WHERE id = $2
      RETURNING id
    `, [archived, id]);

    if (result.rows.length === 0) {
      return null;
    }

    // Fetch the complete item with tags
    return await this.findById(id);
  }

  static async moveItem(id: number, moveData: MoveItemRequest): Promise<Item | null> {
    const client = await pool.connect();

    try {
      await client.query('BEGIN');

      // Get current item
      const currentItem = await client.query(`
        SELECT column_id, position FROM items WHERE id = $1
      `, [id]);

      if (currentItem.rows.length === 0) {
        await client.query('ROLLBACK');
        return null;
      }

      const { column_id: oldColumnId, position: oldPosition } = currentItem.rows[0];
      const { column_id: newColumnId, position: newPosition } = moveData;

      if (oldColumnId === newColumnId) {
        // Moving within the same column
        if (newPosition > oldPosition) {
          // Moving down: shift items between old and new position up
          await client.query(`
            UPDATE items
            SET position = position - 1
            WHERE column_id = $1 AND position > $2 AND position <= $3
          `, [oldColumnId, oldPosition, newPosition]);
        } else {
          // Moving up: shift items between new and old position down
          await client.query(`
            UPDATE items
            SET position = position + 1
            WHERE column_id = $1 AND position >= $2 AND position < $3
          `, [oldColumnId, newPosition, oldPosition]);
        }
      } else {
        // Moving to a different column
        // Shift items in old column up
        await client.query(`
          UPDATE items
          SET position = position - 1
          WHERE column_id = $1 AND position > $2
        `, [oldColumnId, oldPosition]);

        // Shift items in new column down
        await client.query(`
          UPDATE items
          SET position = position + 1
          WHERE column_id = $1 AND position >= $2
        `, [newColumnId, newPosition]);
      }

      // Update the item
      const result = await client.query(`
        UPDATE items
        SET column_id = $1, position = $2, updated_at = NOW()
        WHERE id = $3
        RETURNING id
      `, [newColumnId, newPosition, id]);

      await client.query('COMMIT');

      // Fetch the complete item with tags
      return await this.findById(id);
    } catch (error) {
      await client.query('ROLLBACK');
      throw error;
    } finally {
      client.release();
    }
  }
}